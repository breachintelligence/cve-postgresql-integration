'use strict';

const async = require('async');
const { Pool } = require('pg');

// This is the maximum number of CVEs we will lookup in a single SQL query
const GROUP_SIZE = 20;

// This is the query that we run for summary result lookups. The query will return the most recent CVE report
// for the given array of CVEs
const summaryFields = ['cve_id'];
const summarySql = `SELECT DISTINCT r_outer.cve_id, r_top.id, r_top.time, r_top.data 
    FROM raw_report r_outer
    JOIN LATERAL (
        SELECT * FROM raw_report r_inner
        WHERE r_inner.cve_id = r_outer.cve_id
        ORDER BY r_inner.time DESC
        LIMIT 1
    ) r_top ON TRUE
    where r_outer.cve_id = ANY ($1::text[])
    ORDER BY r_outer.cve_id`;

const detailsSql = `SELECT id, cve_id, time, data FROM raw_report WHERE cve_id = $1 ORDER BY time DESC LIMIT 5`;
let _pool;
let poolSignature = '';
let Logger;

function getPool(options) {
  let optionString =
    options.host + options.user + options.port + options.password + options.database;
  if (poolSignature != optionString) {
    poolSignature = optionString;

    _pool = new Pool({
      connectionLimit: 50,
      host: options.host,
      user: options.user,
      port: options.port,
      password: options.password,
      database: options.database
    });
  }

  return _pool;
}

/**
 *
 * @param entities
 * @param options
 * @param cb
 */
function doLookup(entities, options, cb) {
  let lookupResults = [];
  let pool = getPool(options);

  const groupedCveIds = _groupCveIds(entities);
  const entityLookup = _createLookupMap(entities);

  Logger.trace({ groupedCveIds: groupedCveIds }, 'doLookup');

  async.each(
    groupedCveIds,
    (cveGroup, done) => {
      let query = {
        text: summarySql,
        values: [cveGroup]
      };

      Logger.debug({ query: query }, 'Query');

      pool.query(query, function(error, results) {
        if (error) {
          return done(error);
        }

        Logger.debug({ results: results }, 'SQL Results');
        lookupResults = lookupResults.concat(_processRows(results.rows, entityLookup, cveGroup));
        done(null);
      });
    },
    (err) => {
      if (err) {
        Logger.error({ err: err, stack: err.stack }, 'Error Running Query');
        err = {
          detail: 'Error Running Summary Query',
          debug: {
            stack: err.stack,
            err: err
          }
        };
      } else {
        Logger.debug({ lookupResults: lookupResults }, 'Lookup Results');
      }

      cb(err, lookupResults);
    }
  );
}

function onDetails(lookupObject, options, cb) {
  let pool = getPool(options);
  let query = {
    text: detailsSql,
    values: [lookupObject.entity.value]
  };
  lookupObject.data.details = [];
  pool.query(query, function(error, results) {
    if (error) {
      return cb({
        detail: 'Error Running Details Query',
        error: error
      });
    }

    results.rows.forEach((row) => {
      lookupObject.data.details.push(row);
    });

    cb(null, lookupObject.data);
  });
}

/**
 * Given an array of entities, creates an array of cve ids split into groups the length of GROUP_SIZE.
 * If array can't be split evenly, the final chunk will be the remaining elements.
 * @param entities
 * @returns {Array}
 * @private
 */
function _groupCveIds(entities) {
  const cveGroups = [];
  let group = [];
  for (let i = 0; i < entities.length; i++) {
    group.push(entities[i].value);
    if (group.length === GROUP_SIZE) {
      cveGroups.push(group);
      group = [];
    }
  }
  if (group.length > 0) {
    cveGroups.push(group);
  }
  return cveGroups;
}

function _createLookupMap(entities) {
  const lookup = new Map();
  entities.forEach((entity) => {
    lookup.set(entity.value, entity);
  });
  return lookup;
}

function _processRows(rows, entityLookup, cveGroup) {
  const results = [];
  const cveSet = new Set(cveGroup);

  rows.forEach((row) => {
    const cveId = row.cve_id;
    results.push({
      entity: entityLookup.get(cveId),
      data: {
        summary: summaryFields.reduce((accum, field) => {
          if (typeof row[field] !== 'undefined' && row[field] !== null) {
            accum.push(row[field]);
          }
          return accum;
        }, []),
        details: row
      }
    });
    cveSet.delete(cveId);
  });

  cveSet.forEach((cveId) => {
    results.push({
      entity: entityLookup.get(cveId),
      data: null
    });
  });

  Logger.debug({ processedResults: results }, '_processRows results');

  return results;
}

function startup(logger) {
  Logger = logger;
}

module.exports = {
  doLookup: doLookup,
  onDetails: onDetails,
  startup: startup
};
